package org.d0sl.examples.auto.drome;

/*Generated by MPS */

import javax.swing.JPanel;
import java.awt.GridLayout;
import javax.swing.JFrame;
import javax.swing.UIManager;
import javax.swing.plaf.metal.MetalLookAndFeel;
import javax.swing.UnsupportedLookAndFeelException;
import java.awt.Dimension;
import java.awt.BorderLayout;
import javax.swing.JOptionPane;

/**
 * Represents an abstract autodrome
 */
public abstract class Autodrome {
  public static final int HEIGHT = 12;
  public static final int WIDTH = 16;
  private static final int CELL_SIZE = 70;
  protected final int width = CELL_SIZE * WIDTH;
  protected final int height = CELL_SIZE * HEIGHT;
  protected final JPanel canvas = new JPanel(new GridLayout(HEIGHT, WIDTH), true);
  private final Cell[][] board = new Cell[HEIGHT][WIDTH];
  private final JFrame frame = new JFrame("Autodrome AI");
  public void initializeComponents() {
    try {
      UIManager.setLookAndFeel(new MetalLookAndFeel());
    } catch (UnsupportedLookAndFeelException e) {
      throw new RuntimeException(e);
    }
    for (int i = 0; i < HEIGHT; i++) {
      for (int j = 0; j < WIDTH; j++) {
        boolean shouldBeWall = i == 0 || i == HEIGHT - 1 || j == 0 || j == WIDTH - 1;
        Cell button = (shouldBeWall ? new Wall() : new Cell());
        button.setEnabled(false);
        board[i][j] = button;
        canvas.add(button);
      }
    }
    frame.setPreferredSize(new Dimension(width, height));
    frame.setResizable(true);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.add(BorderLayout.CENTER, canvas);
    frame.setVisible(true);
    frame.pack();
    updateUI();
  }
  public final void run() {
    perform();
  }
  protected abstract void perform();
  public void reportError(String msg) {
    JOptionPane.showMessageDialog(canvas, msg, "Error", JOptionPane.ERROR_MESSAGE);
  }
  public void trace(String msg) {
    JOptionPane.showMessageDialog(canvas, msg, "Trace", JOptionPane.INFORMATION_MESSAGE);
  }
  /**
   *  returns a cell of autodrome
   * 
   */
  protected Cell getCell(int row, int col) {
    return board[row][col];
  }
  /**
   * Sets the cell with (row, col)
   * @param row
   * @param col
   * @param cell
   */
  protected void changeCell(int row, int col, Cell cell) {
    int index = row * WIDTH + col;
    board[row][col] = cell;
    canvas.remove(index);
    canvas.add(board[row][col], index);
  }
  protected abstract void updateUI();
}
