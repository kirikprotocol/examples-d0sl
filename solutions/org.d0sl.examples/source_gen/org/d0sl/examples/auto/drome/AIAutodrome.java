package org.d0sl.examples.auto.drome;

/*Generated by MPS */

import java.util.Random;
import java.util.LinkedList;
import org.d0sl.machine.SemanticMachine;
import javax.swing.SwingUtilities;
import org.d0sl.model.expression.Logical;
import org.d0sl.machine.SemanticException;
import java.util.List;
import java.util.Arrays;

/**
 * Autodrome, which controls the machines, guided by the semantic model.
 */
public class AIAutodrome extends Autodrome {
  private int CAR_NUMBER = 10;
  private int PAUSE = 500;
  private RoboCar[] cars;
  private Random random = new Random();
  private LinkedList<Wall> walls = new LinkedList();
  private LinkedList<RoadSign> signs = new LinkedList();
  private SemanticMachine sm = null;
  /**
   * 
   *  @param sm semantic model
   */
  public AIAutodrome(SemanticMachine sm) {
    this.cars = new RoboCar[CAR_NUMBER];
    this.sm = sm;
  }
  public AIAutodrome() {
    this.cars = new RoboCar[CAR_NUMBER];
  }
  public static void main(String[] args) {
    AIAutodrome script = new AIAutodrome();
    script.initializeComponents();
    script.run();
  }
  @Override
  protected void updateUI() {
    for (int i = 0; i < HEIGHT; i++) {
      for (int j = 0; j < WIDTH; j++) {
        final Cell worldCell = getCell(i, j);
        try {
          SwingUtilities.invokeAndWait(new Runnable() {
            @Override
            public void run() {
              worldCell.init();
            }
          });
        } catch (Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
  }
  @Override
  public void initializeComponents() {
    super.initializeComponents();
    for (Wall wall : walls) {
      changeCell(wall.getRow(), wall.getCol(), wall);
    }
    for (RoadSign sign : signs) {
      changeCell(sign.getRow(), sign.getCol(), sign);
    }
    for (int i = 0; i < cars.length; i++) {
      int row;
      int col;
      Cell c;
      do {
        row = random.nextInt(HEIGHT);
        col = random.nextInt(WIDTH);
        c = getCell(row, col);
      } while (c instanceof Wall || c.isCar() || c instanceof RoadSign);
      int randomDirection = random.nextInt(Direction.values().length);
      cars[i] = new RoboCar(row, col, Direction.values()[randomDirection]);
      cars[i].setModelName("Autodrome");
      cars[i].setName("Car");
      c.setCar(cars[i]);
    }
  }
  @Override
  protected void perform() {
    Random random = new Random();
    while (true) {
      for (int i = 0; i < cars.length; i++) {
        if (sm == null) {
          if (isWallAhead(cars[i]) || isCarAhead(cars[i])) {
            if (isWallLeft(cars[i])) {
              turnRight(cars[i]);
            } else {
              turnLeft(cars[i]);
            }
          } else {
            if (isRoadSignAllowsMove(cars[i])) {
              move(cars[i]);
            } else
            if (isRoadSignAllowsTurnLeft(cars[i])) {
              turnLeft(cars[i]);
            } else
            if (isRoadSignAllowsTurnRight(cars[i])) {
              turnRight(cars[i]);
            }
          }
        } else {
          try {
            if (sm.callPredicate("can move", cars[i]).getValue() == Logical.TRUE) {
              move(cars[i]);
            } else
            if (sm.callPredicate("can stop", cars[i]).getValue() == Logical.TRUE) {
              continue;
            } else {
              boolean canRight = sm.callPredicate("can turn right", cars[i]).getValue() == Logical.TRUE;
              boolean canLeft = sm.callPredicate("can turn left", cars[i]).getValue() == Logical.TRUE;
              if (canLeft && canRight) {
                if (random.nextBoolean()) {
                  turnLeft(cars[i]);
                } else
                turnRight(cars[i]);
              } else
              if (canLeft) {
                turnLeft(cars[i]);
              } else
              if (canRight) {
                turnRight(cars[i]);
              }
            }
          } catch (SemanticException sexp) {
            reportError(sexp.getMessage());
          } catch (Exception exp) {
            reportError(exp.getMessage());
          }
        }
      }
      try {
        Thread.sleep(PAUSE);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      updateUI();
    }
  }
  private Cell getCurrentCell(RoboCar car) {
    return getCell(car.getRow(), car.getCol());
  }
  private Cell getNextCell(RoboCar car) {
    int row = car.getRow();
    int col = car.getCol();
    switch (car.getDirection()) {
      case north:
        return getCell(row - 1, col);
      case east:
        return getCell(row, col + 1);
      case south:
        return getCell(row + 1, col);
      case west:
        return getCell(row, col - 1);
      default:
        return null;
    }
  }
  private Cell getLeftCell(RoboCar car) {
    int row = car.getRow();
    int col = car.getCol();
    switch (car.getDirection()) {
      case north:
        return getCell(row, col - 1);
      case east:
        return getCell(row - 1, col);
      case south:
        return getCell(row, col + 1);
      case west:
        return getCell(row + 1, col);
      default:
        return null;
    }
  }
  private Cell getRightCell(RoboCar car) {
    int row = car.getRow();
    int col = car.getCol();
    switch (car.getDirection()) {
      case north:
        return getCell(row, col + 1);
      case east:
        return getCell(row + 1, col);
      case south:
        return getCell(row, col - 1);
      case west:
        return getCell(row - 1, col);
      default:
        return null;
    }
  }
  private void move(RoboCar car) {
    getCurrentCell(car).unsetCar();
    getNextCell(car).setCar(car);
    car.move();
  }
  private void turnLeft(RoboCar car) {
    car.turnLeft();
  }
  private void turnRight(RoboCar car) {
    car.turnRight();
  }
  public boolean isRoadSignAllowsMove(RoboCar car) {
    RoadSign sign = getRoadSign(car);
    if (sign != null) {
      return sign.getDirection() == car.getDirection();
    }
    return true;
  }
  public boolean isRoadSignAllowsTurnLeft(RoboCar car) {
    RoadSign sign = getRoadSign(car);
    if (sign != null) {
      RoboCar c = new RoboCar(car);
      c.turnLeft();
      return sign.getDirection() == c.getDirection();
    }
    return true;
  }
  public boolean isRoadSignAllowsTurnRight(RoboCar car) {
    RoadSign sign = getRoadSign(car);
    if (sign != null) {
      RoboCar c = new RoboCar(car);
      c.turnRight();
      return sign.getDirection() == c.getDirection();
    }
    return true;
  }
  private RoadSign getRoadSign(RoboCar car) {
    Cell cell = getCurrentCell(car);
    if (cell instanceof RoadSign) {
      return (RoadSign) cell;
    }
    return null;
  }
  public List<RoboCar> getCarsList() {
    return Arrays.asList(cars);
  }
  public boolean isWallAhead(RoboCar car) {
    return getNextCell(car) instanceof Wall;
  }
  public boolean isRoadSign(RoboCar car) {
    return getRoadSign(car) != null;
  }
  public boolean isCarAhead(RoboCar car) {
    return getNextCell(car).isCar();
  }
  public boolean isCarHeadToHead(RoboCar car) {
    Cell next = getNextCell(car);
    if (next.isCar()) {
      RoboCar ahead = next.getCar();
      switch (car.getDirection()) {
        case north:
          return ahead.getDirection() == Direction.south;
        case east:
          return ahead.getDirection() == Direction.west;
        case south:
          return ahead.getDirection() == Direction.north;
        case west:
          return ahead.getDirection() == Direction.east;
        default:
      }
    }
    return false;
  }
  public boolean isWallLeft(RoboCar car) {
    return getLeftCell(car) instanceof Wall;
  }
  public boolean isWallRight(RoboCar car) {
    return getRightCell(car) instanceof Wall;
  }
  public boolean isInterferenceRight(RoboCar car) {
    int row = car.getRow();
    int col = car.getCol();
    Cell diagCell = null;
    Direction dangerDirection = Direction.east;
    switch (car.getDirection()) {
      case north:
        diagCell = getCell(row - 1, col + 1);
        dangerDirection = Direction.west;
        break;
      case east:
        diagCell = getCell(row + 1, col + 1);
        dangerDirection = Direction.north;
        break;
      case south:
        diagCell = getCell(row + 1, col - 1);
        dangerDirection = Direction.east;
        break;
      case west:
        diagCell = getCell(row - 1, col - 1);
        dangerDirection = Direction.south;
        break;
      default:
    }
    return isInterference(diagCell, dangerDirection);
  }
  public boolean isInterferenceLeft(RoboCar car) {
    int row = car.getRow();
    int col = car.getCol();
    Cell diagCell = null;
    Direction dangerDirection = Direction.east;
    switch (car.getDirection()) {
      case north:
        diagCell = getCell(row - 1, col - 1);
        dangerDirection = Direction.east;
        break;
      case east:
        diagCell = getCell(row - 1, col + 1);
        dangerDirection = Direction.south;
        break;
      case south:
        diagCell = getCell(row + 1, col + 1);
        dangerDirection = Direction.west;
        break;
      case west:
        diagCell = getCell(row + 1, col - 1);
        dangerDirection = Direction.north;
        break;
      default:
    }
    return isInterference(diagCell, dangerDirection);
  }
  public boolean isInterferenceAhead(RoboCar car) {
    if (isWallAhead(car)) {
      return false;
    }
    int row = car.getRow();
    int col = car.getCol();
    Cell aheadCell = null;
    Direction dangerDirection = null;
    switch (car.getDirection()) {
      case north:
        aheadCell = getCell(row - 2, col);
        dangerDirection = Direction.south;
        break;
      case east:
        aheadCell = getCell(row, col + 2);
        dangerDirection = Direction.west;
        break;
      case south:
        aheadCell = getCell(row + 2, col);
        dangerDirection = Direction.north;
        break;
      case west:
        aheadCell = getCell(row, col - 2);
        dangerDirection = Direction.east;
        break;
      default:
    }
    return isInterference(aheadCell, dangerDirection);
  }
  private boolean isInterference(Cell aheadCell, Direction dangerDirection) {
    if (aheadCell != null) {
      if (aheadCell.isCar()) {
        if (aheadCell.getCar().getDirection() == dangerDirection) {
          return true;
        }
      }
    }
    return false;
  }
  public boolean addWall(double row, double col) {
    if (col >= 1 && col < WIDTH - 1 && row >= 1 && row < HEIGHT - 1) {
      Wall wall = new Wall();
      wall.setCol((int) col);
      wall.setRow((int) row);
      walls.add(wall);
      return true;
    } else {
      return false;
    }
  }
  public boolean addRoadSign(double row, double col, String direction) {
    if (col >= 1 && col < WIDTH - 1 && row >= 1 && row < HEIGHT - 1) {
      try {
        RoadSign sign = new RoadSign(Direction.valueOf(direction));
        sign.setCol((int) col);
        sign.setRow((int) row);
        signs.add(sign);
        return true;
      } catch (IllegalArgumentException ex) {
        return false;
      }
    } else {
      return false;
    }
  }
  public boolean start(double carNumber, double pause) {
    long cars = Math.round(carNumber);
    if (cars <= 20) {
      CAR_NUMBER = (int) cars;
      this.cars = new RoboCar[CAR_NUMBER];
    }
    long millis = Math.round(pause);
    if ((millis > 20) && (millis <= 1000)) {
      this.PAUSE = (int) millis;
    }
    initializeComponents();
    run();
    return true;
  }
}
